<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <!-- 行動裝置自適應 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>中文點餐系統</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 10px;
      padding: 0;
    }
    input, button {
      margin: 5px;
      padding: 10px;
      font-size: 16px;
    }
    @media (max-width: 600px) {
      input, button { font-size: 18px; }
    }
    /* Modal 樣式 */
    .modal {
      display: none;
      position: fixed;
      z-index: 1;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.4);
    }
    .modal-content {
      background-color: #fefefe;
      margin: 15% auto;
      padding: 20px;
      border: 1px solid #888;
      width: 90%;
      max-width: 500px;
    }
    .close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }
    .close:hover,
    .close:focus {
      color: black;
      text-decoration: none;
    }
  </style>
</head>
<body>
  <h1>中文點餐系統</h1>
  
  <!-- 點餐區：輸入中文後自動轉換成英文點餐關鍵字 -->
  <section>
    <h2>請輸入中文菜品名稱</h2>
    <input type="text" id="orderInput" placeholder="例如：蔥油餅">
    <button onclick="orderFromChinese()">送出訂單</button>
    <p>訂單結果：<span id="orderResult"></span></p>
  </section>
  
  <!-- 自動讀取轉譯字庫 -->
  <section>
    <h2>轉譯字庫載入狀態</h2>
    <p id="dbStatus">尚未載入字庫資料...</p>
  </section>
  
  <!-- 菜單管理區：顯示目前菜單及編輯（新增、下載、上傳）功能 -->
  <section>
    <h2>菜單管理</h2>
    <button onclick="openMenuModal()">新增菜單</button>
    <button onclick="downloadMenuData()">下載菜單資料</button>
    <button onclick="document.getElementById('uploadMenuFile').click()">上傳菜單資料</button>
    <input type="file" id="uploadMenuFile" accept=".txt" style="display:none;" onchange="uploadMenuData()">
    <div id="menuList"></div>
  </section>
  
  <!-- 新增菜單彈出視窗 -->
  <div id="menuModal" class="modal">
    <div class="modal-content">
      <span class="close" onclick="closeMenuModal()">&times;</span>
      <h3>新增菜單項目</h3>
      <div class="form-group">
        <label for="menuName">菜品名稱 (中文)：</label>
        <input type="text" id="menuName" placeholder="例如: 蔥油餅">
      </div>
      <div class="form-group">
        <label for="menuKey">點餐關鍵字 (英文)：</label>
        <input type="text" id="menuKey" placeholder="自動轉譯" readonly>
      </div>
      <div class="form-group">
        <label for="menuPrice">價格：</label>
        <input type="number" id="menuPrice" placeholder="例如: 20">
      </div>
      <button onclick="saveMenuItem()">儲存</button>
      <button onclick="closeMenuModal()">取消</button>
    </div>
  </div>
  
  <script>
    // 全域字庫映射（由同一伺服器的 database.txt 載入）
    let groupMapping = {};
    let charMapping = {};
    
    // 內建菜單，可透過菜單編輯系統動態新增項目
    let menu = {
      "chonyobin": { name: "蔥油餅", price: 20 }
    };
    
    // 更新並顯示目前菜單
    function updateMenuDisplay() {
      let menuListDiv = document.getElementById("menuList");
      menuListDiv.innerHTML = "";
      let ul = document.createElement("ul");
      for (let key in menu) {
        if (menu.hasOwnProperty(key)) {
          let li = document.createElement("li");
          li.textContent = key + " : " + menu[key].name + " - " + menu[key].price + "元";
          ul.appendChild(li);
        }
      }
      menuListDiv.appendChild(ul);
    }
    updateMenuDisplay();
    
    // 自動從同一伺服器的 database.txt 讀取字庫資料
    function loadTranslationDatabase() {
      fetch("database.txt")
        .then(response => {
          if (!response.ok) {
            throw new Error("無法讀取 database.txt");
          }
          return response.text();
        })
        .then(text => {
          const db = JSON.parse(text);
          if (db.groupMapping && db.charMapping) {
            groupMapping = db.groupMapping;
            charMapping = db.charMapping;
            document.getElementById("dbStatus").innerText = "字庫資料載入成功！";
          } else {
            document.getElementById("dbStatus").innerText = "database.txt 格式不正確！";
          }
        })
        .catch(err => {
          document.getElementById("dbStatus").innerText = "載入字庫資料失敗：" + err.message;
        });
    }
    loadTranslationDatabase();
    
    // 下載菜單資料，將 menu 物件以 JSON 格式下載成 txt 檔案
    function downloadMenuData() {
      const dataStr = JSON.stringify(menu, null, 2);
      const blob = new Blob([dataStr], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "menu.txt";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    
    // 上傳菜單資料，讀取 txt 檔案後更新 menu 物件
    function uploadMenuData() {
      const fileInput = document.getElementById("uploadMenuFile");
      if (fileInput.files.length === 0) return;
      const file = fileInput.files[0];
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = JSON.parse(e.target.result);
          // 檢查格式：預期為物件，且每個屬性皆含有 name 與 price
          if (typeof data === 'object' && data !== null) {
            let valid = true;
            for (let key in data) {
              if (data.hasOwnProperty(key)) {
                if (typeof data[key].name !== 'string' || typeof data[key].price !== 'number') {
                  valid = false;
                  break;
                }
              }
            }
            if (valid) {
              menu = data;
              updateMenuDisplay();
              alert("菜單資料已成功上傳！");
            } else {
              alert("上傳的菜單格式不正確！");
            }
          } else {
            alert("上傳的菜單格式不正確！");
          }
        } catch (err) {
          alert("上傳失敗，請確認檔案格式正確！");
        }
      };
      reader.readAsText(file);
    }
    
    // Levenshtein 距離函式
    function levenshteinDistance(a, b) {
      const m = a.length, n = b.length;
      const dp = [];
      for (let i = 0; i <= m; i++) {
        dp[i] = [];
        dp[i][0] = i;
      }
      for (let j = 0; j <= n; j++) {
        dp[0][j] = j;
      }
      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          dp[i][j] = Math.min(
            dp[i - 1][j] + 1,
            dp[i][j - 1] + 1,
            dp[i - 1][j - 1] + (a[i - 1] === b[j - 1] ? 0 : 1)
          );
        }
      }
      return dp[m][n];
    }
    
    // 計算相似度：1 - (Levenshtein 距離 / 最大長度)
    function similarity(a, b) {
      const maxLen = Math.max(a.length, b.length);
      if (maxLen === 0) return 1;
      const dist = levenshteinDistance(a, b);
      return 1 - dist / maxLen;
    }
    
    // 從中文輸入轉換成英文點餐關鍵字，並依模糊比對下訂單
    function orderFromChinese() {
      const input = document.getElementById("orderInput").value.trim();
      if (!input) {
        alert("請輸入中文菜品名稱！");
        return;
      }
      let converted = "";
      for (let i = 0; i < input.length; i++) {
        const ch = input.charAt(i);
        if (charMapping[ch] !== undefined) {
          converted += charMapping[ch];
        }
      }
      console.log("轉換結果：" + converted);
      
      // 若有精確匹配，直接下訂單
      if (menu[converted]) {
        const dish = menu[converted];
        document.getElementById("orderResult").innerText =
          "您點的是 " + dish.name + "，價格為 " + dish.price + "元";
        return;
      }
      
      // 否則執行模糊比對，選出相似度最高的關鍵字
      let bestKey = "";
      let bestSim = 0;
      for (let key in menu) {
        if (menu.hasOwnProperty(key)) {
          const sim = similarity(converted, key);
          if (sim > bestSim) {
            bestSim = sim;
            bestKey = key;
          }
        }
      }
      
      if (bestKey) {
        const dish = menu[bestKey];
        document.getElementById("orderResult").innerText =
          "依模糊比對，您點的是 " + dish.name + "（匹配關鍵字：" + bestKey +
          "，相似度：" + (bestSim * 100).toFixed(1) + "%），價格為 " + dish.price + "元";
      } else {
        document.getElementById("orderResult").innerText =
          "無法依模糊比對出合適的點餐關鍵字 (" + converted + ")";
      }
    }
    
    // 開啟與關閉新增菜單的彈出視窗
    function openMenuModal() {
      document.getElementById("menuModal").style.display = "block";
    }
    function closeMenuModal() {
      document.getElementById("menuModal").style.display = "none";
    }
    
    // 儲存新增的菜單項目
    function saveMenuItem() {
      const key = document.getElementById("menuKey").value.trim().toLowerCase();
      const name = document.getElementById("menuName").value.trim();
      const price = parseFloat(document.getElementById("menuPrice").value.trim());
      if (!key || !name || isNaN(price)) {
        alert("請填寫完整且正確的菜單資料！");
        return;
      }
      menu[key] = { name: name, price: price };
      updateMenuDisplay();
      closeMenuModal();
      // 清空輸入欄位
      document.getElementById("menuName").value = "";
      document.getElementById("menuKey").value = "";
      document.getElementById("menuPrice").value = "";
    }
    
    // 當「菜品名稱 (中文)」欄位輸入變動時，自動轉譯生成英文點餐關鍵字
    document.getElementById("menuName").addEventListener("input", function() {
      let name = this.value.trim();
      let key = "";
      for (let i = 0; i < name.length; i++) {
        let ch = name.charAt(i);
        if (charMapping[ch] !== undefined) {
          key += charMapping[ch];
        }
      }
      document.getElementById("menuKey").value = key;
    });
    
    // 點擊視窗空白處關閉彈出視窗
    window.onclick = function(event) {
      const modal = document.getElementById("menuModal");
      if (event.target == modal) {
        closeMenuModal();
      }
    }
  </script>
</body>
</html>